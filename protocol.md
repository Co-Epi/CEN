# CEN Protocol

This is a work-in-progress document.  So far, it just has copies of text from
various Google Docs, Slack threads, etc., to provide a single source of truth
to iterate the specification.

## Introduction and goals

Contact tracing is used to identify exposures to a contagion and allow
treatment, isolation, or quarantine. This document describes the security
considerations for a protocol on mobile devices that uses a phone’s ability to
broadcast short range radio announcements (via Bluetooth) to support contact
tracing and notification while preventing users from being stalked, tracked,
blackmailed, or otherwise suffering from the exposure of their detailed
location history to the public. 

A contact tracing protocol should allow a user Alice to 

1. Record her contacts, termed contact events, with other app users locally on
   her own device;

2. At a later time notify those users she has had contact with that she has
   tested positive (or in the case of CoEpi that she has symptoms). 

As the app is always on and continuously broadcasting, this could easily reveal
a user's entire location history. Preventing this requires a strong security
model. In particular, no one (even app users themselves) should learn anything
about anyone else they contact if there are no positive reports. Furthermore,
to facilitate adoption, no personal identifying information should be collected
by the app. In the event of a positive test (respectively self-reported
symptoms), the privacy impact should a) only be on the person reporting and b)
be as minimal as possible. This is crucial to facilitating adoption and
complying with various regulations across states and countries.

## Straw man solution:

All mobile devices running the app periodically generate a random Contact Event
Number (CEN), store the CEN, and broadcast it using Bluetooth. At the same
time, the app also listens for and records the CENs generated by other devices.
When a user tests positive (or self reports symptoms), using the app she
uploads the CENs she generated to a server. All apps periodically download the
list of CENs for infected individuals. Each app then checks the list of
positive CENs against the list of CENs they observed and recorded locally. The
intersection of these do lists is the set of positive contacts.

Intuitively, this preserves privacy before a positive test (resp. symptom
reports for CoEpi) because all identifiers are random and unlinkable to each
other. And after a report, no information is revealed about who had contact
with the infected individual because all checks are done locally on the device.
For the positive contacts, provided CENs are uploaded in appropriately sized
batches, then no information should be leaked about the connections between
positive contacts. 

## Compressing CEN uploads for scalability:

Although completely random CENs are appealing from a privacy perspective, they
result in a potentially prohibitive amount of data uploaded and downloaded by
the app. In a naive setup without sharding by location, we might be talking
about terabytes of data ( FIXME LINK TO SPREADSHEETs with calculations). While
location based sharding is a possibility for future versions of the protocol,
at present it raises too many open questions. 

To ensure scalability, we upload a compressed representation of all the CENs a
user generates. To do this, we use cryptography to generate the entire sequence
of CENs for a user from a short key. As a result, a single 128 bit key can be
used to represent all CENs a user will ever generate. The exact method of
deriving keys is currently under discussion, but there are multiple feasible
approaches and it is simply a matter of picking one. Provided the CEN are
cryptographically pseudorandom, the particular properties of the generation
process should not affect security, but it may affect scalability.The existing
designs are detailed here and here.

## Key rotation and compression factor:

One important question is how frequently do we change the key. If it does not
change, then uploading the key on a positive test reveals all contacts a user
has ever had, even several months ago. On the other extreme, we could change
the key every time we generate a CEN, then we are back to the strawman random
CEN and the resulting scalability problems. What is an appropriate middle
ground?

## Rotation considerations:

The key rotation interval must balance a trade off between security and
scalability. Consider, for example, rotating keys every day. This should result
in reasonable amounts of data being uploaded and downloaded. However, it means
any user who tested positive would associate all the CENs they broadcast in a
given day together by revealing the key that generated them. This has two
consequences: 1) other users could “compare notes” and see if they saw CENs
generated by the same key and therefore encountered the same person. 2) The
user could easily be tracked during that day by anyone who passively listens
for CENs and notes their locations. 

Discussions around the first concern concluded it was the less problematic of
the two attacks. To actively mount the attack would require users to actively
find each other, collude, and compare data. And the end result is being able to
infer they had contact with the same person. It is worth noting that this may
be possible for humans to do on their own in many cases, simply by comparing
who they have talked to, etc or looking at what time an encounter happened and
remembering where they were and who they were meeting. It is also likely that
the CoEpi app will allow users to locally store location history data to assist
with identifying where a contact occurred, and therefore how likely it was to
have represented a possible exposure. Since identifying such exposures is the
whole point of the app, recipients can be expected (by the users reporting
symptoms or test results) to receive and use such information for whatever
purposes they deem appropriate. Any inappropriate use of such information will
need to be avoided by social, not technological, means. 

However, the second issue is a major concern. BLE beacon tracking is already
used in some settings. Moreover, if contact tracing apps become ubiquitous,
enterprise solutions for tracking contacts for businesses and public spaces
will emerge rapidly. This will result in CENs being recorded in bulk and likely
aggregated in cloud managed services. In this setting then, linking 24 hours of
CENs together will be easy and equivalent to simply revealing a user’s location
history for that day (if they later report symptoms or a positive test). Worse,
due to the relative simplicity of re-identification attacks, it should be
fairly simple to link each 24 hour snippet of a user’s location history
together to compute a history over a week or more. Substantially shortening the
interval reduces this risk. It does not completely eliminate it, but as a
primary defense against BLE beacon tracking, re-keying intervals should be as
short as feasible. 

Note, however, re-keying is much less of a concern if contacts are made based
on symptom reports. If users are notified of the contact and their symptoms,
and the symptom descriptors are reasonably unique, then with high probability
all CENs which have a report containing the same symptoms are from the same
user. This is the same information that would be leaked by using a long
rekeying interval.

## Further considerations.

In the setting where CENs are continuously broadcast, we must also choose the
rate at which we change from one CEN to another.  Again, the longer a CEN lasts
for, the greater the risk of tracking. In particular, in many settings it will
be easy to infer at the time that one CEN disappears and another appears that
they are the same device. This won’t be perfect, but if CENs change
infrequently, it need not be perfect to recover a pretty good trace of a user's
location history.

Finally, Bluetooth itself exposes a number of tracking opportunities due to the
handling of MAC addresses and other identifiers. Unfortunately, the degree to
which these are properly randomized varies considerably across devices, with
many devices not implementing strong privacy protections. See 
[this paper](https://arxiv.org/pdf/2003.11511.pdf) for an
overview on privacy issues. In all cases, the duration for which a CEN lasts
should be a multiple of the frequency with which MAC address and other
identifiers in the BLE protocol get randomized. For example, if the MAC address
changes every minute, then the CEN can change every minute, every 10 seconds,
or every second. But it cannot change every two minutes or change e.g. every 7
seconds. In the latter two cases, then when the MAC address changed, the CEN
would not. Anyone observing (MAC A, CEN 1), then (MAC B, CEN 1), then (MAC B,
CEN 2) can conclude they are all the same device because all identifiers don’t
change at the same time. This would entirely compromise Bluetooth privacy. 

## George Danezis proposal of 3/27/20

Builds on prior work from CoEpi (?)

The following CEN derivation function employs only a secure cryptographic hash function `H`:

### CEN Key Derivation

#### CEN Key Generation Initialization.  

The app would initialize the CEN generator with:
- `S`, a secret nonce, of at least 128 bits (optionally a public verification key `vk` from a signature scheme, with the corresponding signing key `sk` remaining always secret);
- `L = H(S)`, a short label;
- `K_0`, a fresh secret key for the session. (A session ends when a report of an infection is filled).

#### CEN Key Generation.  

For each period `i`, the key would be updated:
```
K_i ← H(K_{i-1}, L)
```

#### CEN Broadcast.  

For each period `i`, CENs would be derived as
```
CEN_i = H(K_i, period_i)
```
where `period_i` is an integer denoting the period for the `CEN_i`.

### Operations

#### Reveal

Upon a positive diagnosis, the app broadcasts to a health authority database:
the short label `L`, a key `K_{j-1}`, and the initial period `j` and number of
periods `j_max`. Other application users download `K_{j-1}`, `j`, and `j_max`,
and can compute all subsequent `K_j` and `CEN_j`s and compare them with the
ones seen on the phone.  The comparison here is purely string comparison, and
therefore efficient string search algorithms can be used on the phone. The
period the CEN was active can also be compared with the time a CEN was observed
to protect against replayed CENs from the past.  

#### Delete

After some days are past (with no symptoms), older
versions of the key before Ki can be deleted, making the link of the phone with
older CENs unrecoverable.

### Discussion

The advantage of the above over the proposals below is:

Given a new Ki the operation on the phone to match its associated CENs with
local observed CENs is efficient. There are 2x periods applications of a hash
function, and then only string matching – which is efficient through indexing. 

**Mitigating impersonation**: The key leverage you have is the trusted health
worker that supervises the positive test, and enables the contact tracing alert
(that broadcasts key `K_i` to derive CENs).  How can the protocol assist the
health worker (and its app) to ensure that reported CENs / `K_i`s are not
impersonations?

**Central admission control setting**: Since `L = H(S)`, where `S` is a secret
nonce, the app can prove to the healthcare worker that it generated the keys `K_i`
by revealing `S`.  However, if someone merely observes `K_i` and `L` (as part of the
contract tracing protocol), they cannot extract `S` and therefore cannot convince
any health workers to include the `K_i`/CENs they are merely relaying. This relies
on the honesty of health workers to check `L = H(S)` and not reveal the `S`
provided.

**Public verifiability**: If we set `S = vk` for `vk` for a `(vk, sk)` key pair, with
`sk` only known to the user reporting, then we can include a signature in the
report to prevent others impersonating the CENs and including them in their
report. In that scheme we provide a signature on `(S = vk, L, Kj-1, j-1, j_max)`
with the report. Others accept if the signature is valid under the included `vk`.
In this scheme the health authorities or anyone else can check the signed
record, and do not have to be trusted to mitigate impersonation.
